---
title: 故障注入
---

# 故障注入: 代码级故障模拟

## 背景
对于一个大型的分布式的微服务系统，模拟各个环节、各个服务调用链过程中的异常十分必要。且这些故障模拟必须做到无侵入地集成到系统中，可以手工激活这些故障观测系统表现是否符合期望。

## 方案期望
* 功能诉求:
1. 微服务中某个服务出现随机延迟、某个服务不可用。
2. 存储系统磁盘 I/O 延迟增加、I/O 吞吐量过低、落盘时间长。
3. 调度系统中出现热点，某个调度指令失败。
4. 充值系统中模拟第三方重复请求充值成功回调接口。
5. 游戏开发中模拟玩家网络不稳定、掉帧、延迟过大等，以及各种异常输入（外挂请求）情况下系统是否正确工作。

* 方案诉求
1. 不能影响正常功能逻辑，不能对功能代码有任何侵入
2. 故障注入的代码最终不能出现在最终发行的二进制文件中。
3. 故障注入的代码必须是易读、易写并且能引入编译器检测。
4. 支持并行测试，可以通过指定控制某个故障点是否激活

> `Failpoint` 项目 就是为此而生，它是 FreeBSD failpoints 的 Golang 实现，允许在代码中注入错误或异常行为， 并由环境变量或代码动态激活来触发这些异常行为。Failpoint 能用于各种复杂系统中模拟错误处理来提高系统的容错性、正确性和稳定性；对于任何一个 Golang 代码的源文件，可以通过解析出这个文件的语法树，遍历整个语法树，找出所有 failpoint 注入点，然后对语法树重写，转换成想要的逻辑。

## failpoint使用
### 0.安装
```
cd $GOPATH/src

mkdir -p github.com/pingcap

cd github.com/pingcap

git clone https://github.com/pingcap/failpoint.git
 
cd failpoint

make
GO111MODULE=on CGO_ENABLED=0 GO111MODULE=on go build  -ldflags '-X "github.com/pingcap/failpoint/failpoint-ctl/version.releaseVersion=12f4ac2-dev" -X "github.com/pingcap/failpoint/failpoint-ctl/version.buildTS=2019-11-15 09:41:49" -X "github.com/pingcap/failpoint/failpoint-ctl/version.gitHash=12f4ac2fd11dfc6b2f7018b00bb90f61a5b6b692" -X "github.com/pingcap/failpoint/failpoint-ctl/version.gitBranch=master" -X "github.com/pingcap/failpoint/failpoint-ctl/version.goVersion=go version go1.13 darwin/amd64"' -o bin/failpoint-ctl failpoint-ctl/main.go
failpoint-ctl build successfully :-) !
```

编译后，生成可执行文件failpoint-ctl：

```
ll bin
total 6840
-rwxr-xr-x  1 lanyang  staff   3.3M 11 15 17:41 failpoint-ctl
```

### 1.注入故障代码

```go
package main

import "github.com/pingcap/failpoint"

func main() {
    failpoint.Inject("testPanic", func() {
        panic("failpoint triggerd")
    })
}
```

### 2.代码转换

将代码转换为故障注入代码
```
$GOPATH/src/github.com/pingcap/failpoint/bin/failpoint-ctl enable
```

将代码还原
```
$GOPATH/src/github.com/pingcap/failpoint/bin/failpoint-ctl disable
```

### 3.代码执行&激活故障
正常执行
```
./your-program
```

激活故障
```
GO_FAILPOINTS="main/testPanic=return(true)" ./your-program
```